记录下每题错误的地方

[LeetCode 热题 100 - 学习计划 - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/studyplan/top-100-liked/)

---

# LeetCode hot 100

# 哈希（3 题）
- [1. 两数之和](https://leetcode.cn/problems/two-sum/)
```java
class Solution {
  public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    int n = nums.length;
    for (int i = 0; i < n; i++) {
      if (map.containsKey((target - nums[i]))) {
        return new int[] { map.get(target - nums[i]), i };
      }

      map.put(nums[i], i);
    }

    return new int[] { -1, -1 };
  }
}
```

- [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        int n = strs.length;
        Map<String, List<String>> map = new HashMap<>();
        for (int i = 0; i < n; i++) {
            char[] chars = strs[i].toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);

            List<String> list = map.getOrDefault(key, new ArrayList<>());
            list.add(strs[i]);
            map.put(key, list);
        }

        return new ArrayList<>(map.values());
    }
}
```

```
map 的 key 是 sort 后的字符数组
```

- [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)
```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        int n = nums.length;
        int ans = 0;
        for(int i = 0;i < n;i++){
            set.add(nums[i]);
        }

        for(int x: set){
            int cnt = 1;
            if (set.contains(x - 1)){
                continue;
            }

            int y = x + 1;
            while(set.contains(y)){
                cnt++;
                y++;
            }

            ans = Math.max(ans,cnt);
        }

        return ans;
    }
}
```

```
暴力即可，set 去重，然后遍历 set 通过 while 循环找最长连续
```

# 双指针（4 题）
- [283. 移动零](https://leetcode.cn/problems/move-zeroes/)
```java
class Solution {
    public void moveZeroes(int[] nums) {
        int i = 0;
        int j = 0;
        int n = nums.length;
        for (i = 0, j = 0; j < n; j++) {
            if (nums[j] != 0) {
                swap(nums, i, j);
                i++;
            }
        }
    }

    public void swap(int[] nums, int l, int r) {
        int temp = nums[l];
        nums[l] = nums[r];
        nums[r] = temp;
    }
}
```

```
等价于原地创建新数组，i 是新数组的下标，j 用来遍历原数组
```

- [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
```java
class Solution {
    public int maxArea(int[] height) {
        int l = 0;
        int r = height.length - 1;
        int ans = 0;
        while (l < r) {
            int h = Math.min(height[l], height[r]);
            int d = r - l;
            ans = Math.max(ans, d * h);
            if (height[l] < height[r]) {
                l++;
            } else {
                r--;
            }
        }
        return ans;
    }
}
```

- [15. 三数之和](https://leetcode.cn/problems/3sum/)
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        int n = nums.length;
        Arrays.sort(nums);

        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                break;
            }

            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            int l = i + 1;
            int r = n - 1;
            while (l < r) {
                int sum = nums[i] + nums[l] + nums[r];
                if (sum > 0) {
                    r--;
                } else if (sum < 0) {
                    l++;
                } else {
                    ans.add(List.of(nums[i], nums[l], nums[r]));
                    l++;
                    r--;
                    while (l < r && nums[l] == nums[l - 1]) l++;
                    while (l < r && nums[r] == nums[r + 1]) r--;
                }
            }
        }
        return ans;
    }
}
```

```
去重的方式可以想一想，nums[i] 只取第一个，对于相同的 i，l 和 r 也只取第一个
```

- [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int ans = 0;
        int[] lMax = new int[n];
        int[] rMax = new int[n];
        lMax[0] = height[0];
        rMax[n - 1] = height[n - 1];

        for (int i = 1; i < n; i++) {
            lMax[i] = Math.max(lMax[i - 1], height[i]);
        }

        for (int i = n - 2; i >= 0; i--) {
            rMax[i] = Math.max(rMax[i + 1], height[i]);
        }

        for (int i = 0; i < n; i++) {
            ans += Math.min(lMax[i], rMax[i]) - height[i];
        }

        return ans;
    }
}
```

```
典中典
```


# 滑动窗口（2 题）

- [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int ans = 0;
        Set<Character> set = new HashSet<>();
        int n = s.length();
        int l = 0;
        int r = 0;
        for (r = 0; r < n; r++) {
            char c = s.charAt(r);
            while (set.contains(c)) {
                set.remove(s.charAt(l));
                l++;
            }

            set.add(c);
            ans = Math.max(ans, r - l + 1);

        }
        return ans;
    }
}
```

- [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)
```java
class Solution {
    int[] cntP = new int[26];
    int[] cntS = new int[26];
    List<Integer> ans = new ArrayList<>();

    public List<Integer> findAnagrams(String s, String p) {
        for (int i = 0; i < p.length(); i++) {
            cntP[p.charAt(i) - 'a']++;
        }

        int l = 0;
        int r = 0;
        for (r = 0; r < s.length(); r++) {
            char c = s.charAt(r);
            cntS[c - 'a']++;

            if (r - l + 1 > p.length()) {
                cntS[s.charAt(l) - 'a']--;
                l++;
            }

            if (check()) {
                ans.add(l);
            }
        }
        return ans;
    }

    public boolean check() {
        for (int i = 0; i < 26; i++) {
            if (cntS[i] != cntP[i]) {
                return false;
            }
        }
        return true;
    }
}
```

```
cnt[26] 数组存异位字符数组，完全相同则符合题目要求
```


# 子串（3 题）

- [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

![[力扣 hot 100.png|352]]

前缀和中 map 这段的核心逻辑如上图
也可以用前两版的前缀和，练一下前缀和
边算前缀和边算 ans
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int sum = 0;
        int n = nums.length;
        Map<Integer, Integer> cnt = new HashMap<>();
        int ans = 0;
        cnt.put(0, 1);
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            ans += cnt.getOrDefault(sum - k, 0);
            cnt.put(sum, cnt.getOrDefault(sum, 0) + 1);
        }
        return ans;
    }
}
```

单独计算前缀和版：
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int ans = 0;
        int[] sum = new int[n + 1];
        for (int i = 0; i < n; i++) {
            sum[i + 1] = sum[i] + nums[i];
        }

        Map<Integer, Integer> cnt = new HashMap<>();
        cnt.put(0, 1);
        for (int i = 0; i < n; i++) {
            ans += cnt.getOrDefault(sum[i + 1] - k, 0);
            cnt.put(sum[i + 1], cnt.getOrDefault(sum[i + 1], 0) + 1);
        }
        return ans;
    }
}
```

```
只要知道 s[i] 是 s[0,...,i-1] 之和即可
```

- [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            while (!deque.isEmpty() && nums[i] > nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offer(i);

            if (i - deque.peek() + 1 > k) {
                deque.poll();
            }

            if (i - k + 1 >= 0) {
                ans[i - k + 1] = nums[deque.peek()];
            }
        }

        return ans;
    }
}
```

```
这里用到的是双端队列，注意这里没有 popLast() 方法，只有 pollLast() 把他看成队列即可
push 的时候保持内部递减，因为左边小于右边的肯定不可能是答案
内部左边是最大值，也就是答案（前提是左边在范围内）
```

- [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)
  参考：[76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/solutions/258513/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/?envType=study-plan-v2&envId=top-100-liked)
```java
class Solution {
    public String minWindow(String s, String t) {
        int ansLeft = -1;
        int ansRight = s.length();
        int[] need = new int[128];
        int count = t.length();

        for (int i = 0; i < count; i++) {
            need[t.charAt(i)]++;
        }

        int r = 0;
        int l = 0;
        for (r = 0; r < s.length(); r++) {
            char c = s.charAt(r);
            if (need[c] > 0) {
                count--;
            }
            need[c]--;

            while (count == 0) {
                if (r - l < ansRight - ansLeft) {
                    ansLeft = l;
                    ansRight = r;
                }

                c = s.charAt(l);
                l++;
                need[c]++;
                if (need[c] > 0) {
                    count++;
                }
            }
        }
        return ansLeft == -1 ? "" : s.substring(ansLeft, ansRight + 1);
    }
}
```

```
r 不断往右，直到符合要求，这个时候 l 不断往右，直到不符合要求
不需要的字符最多就会让 need 加到 0，如果加到 > 0 的话，就说明需要这个字符（count++）
```

# 普通数组（5 题）

- [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        int ans = nums[0];
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```

```
dp[i] 是 nums[i] 结尾的最大大小
dp[n - 1] 只是最后结尾的大小，所以应该用 ans 记录全局大小
```

- [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int n = intervals.length;
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        List<int[]> ans = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            int[] cur = intervals[i];

            if (i == 0) {
                ans.add(cur);
                continue;
            }

            int[] pre = ans.get(ans.size() - 1);
            if (pre[1] >= cur[0]) {
                pre[1] = Math.max(pre[1], cur[1]);
            } else {
                ans.add(cur);
            }
        }

        return ans.toArray(new int[ans.size()][]);
    }
}
```

```
return ans.toArray(new int[ans.size()][]);
括号里面写的是数组的大小
```

- [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)
```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;

        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }

    public void reverse(int[] nums, int l, int r) {
        while (l < r) {
            int temp = nums[l];
            nums[l] = nums[r];
            nums[r] = temp;
            l++;
            r--;
        }
    }
}
```

- [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)
  参考：[238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/solutions/2783788/qian-hou-zhui-fen-jie-fu-ti-dan-pythonja-86r1/?envType=study-plan-v2&envId=top-100-liked)
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] l = new int[n];
        int[] r = new int[n];
        int[] ans = new int[n];

        l[0] = 1;
        for (int i = 1; i < n; i++) {
            l[i] = l[i - 1] * nums[i - 1];
        }

        r[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            r[i] = r[i + 1] * nums[i + 1];
        }

        for (int i = 0; i < n; i++) {
            ans[i] = l[i] * r[i];
        }

        return ans;
    }
}
```

```
注意 l[i] 表示 [0,i-1] 的乘积，r[i] 表示 [i+1,n-1] 的乘积
所以 l[0] = [0,-1] 的乘积就是 1 
这样当 i = 1 的时候就等价于 1 * r[1]
```

- [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            while (nums[i] >= 1 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                int j = nums[i] - 1;
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }

        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }

        return n + 1;
    }
}
```

```
换座位，只找正数，所以只找 1 <= nums[i] <= n 的数据
nums[i] 应该在 nums[i] - 1 的下标处
对于每个位置，必须换到换不了为止，所以要用 while
如果用 if 的话意思是把 nums[i] 换到正确位置，然后 i++，但是 i 位置不一定是正确的数字，所以必须用 while 一直换，换到符合要求（换到换不了为止）
```


# 矩阵（4 题）
- [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)
```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        boolean row = false;
        boolean col = false;
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                col = true;
                break;
            }
        }

        for (int i = 0; i < n; i++) {
            if (matrix[0][i] == 0) {
                row = true;
                break;
            }
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        for (int i = 1; i < m; i++) {
            if (matrix[i][0] == 0) {
                for (int j = 0; j < n; j++) {
                    matrix[i][j] = 0;
                }
            }
        }

        for (int i = 1; i < n; i++) {
            if (matrix[0][i] == 0) {
                for (int j = 0; j < m; j++) {
                    matrix[j][i] = 0;
                }
            }
        }

        if (row) {
            for (int i = 0; i < n; i++) {
                matrix[0][i] = 0;
            }
        }
        if (col) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```

```
注意操作都是从 int i = 1 开始的
第零行第零列最后才判断
```

- [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        List<Integer> ans = new ArrayList<>();
        int[] dx = { 0, 1, 0, -1 };
        int[] dy = { 1, 0, -1, 0 };
        int x = 0;
        int y = 0;
        int idx = 0;

        for (int i = 0; i < m * n; i++) {
            ans.add(matrix[x][y]);
            matrix[x][y] = Integer.MAX_VALUE;
            
            int nx = x + dx[idx];
            int ny = y + dy[idx];
            
            if (nx < 0 || nx >= m || ny < 0 || ny >= n || matrix[nx][ny] == Integer.MAX_VALUE) {
                idx = (idx + 1) % 4;
                nx = x + dx[idx];
                ny = y + dy[idx];
            }

            x = nx;
            y = ny;
        }

        return ans;
    }
}
```

错误地方：你是在“走到非法位置之后”才转向，**但没有回退**
```java
// 错误代码
if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] == Integer.MAX_VALUE) {
    idx = (idx + 1) % 4;
    x = x + dx[idx];
    y = y + dy[idx];
}
ans.add(matrix[x][y]);
```
只有在下一个位置没问题的时候，才让 x 和 y 变成下一个位置

- [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)
```java
class Solution {
    public void rotate(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < i; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        for (int i = 0; i < m; i++) {
            int l = 0;
            int r = n - 1;
            while (l < r) {
                int temp = matrix[i][l];
                matrix[i][l] = matrix[i][r];
                matrix[i][r] = temp;
                l++;
                r--;
            }
        }
    }
}
```

- [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;

        for (int i = 0; i < m; i++) {
            int l = 0;
            int r = n - 1;
            while (l <= r) {
                int mid = l + (r - l) / 2;
                if (matrix[i][mid] > target) {
                    r = mid - 1;
                } else if (matrix[i][mid] < target) {
                    l = mid + 1;
                } else {
                    return true;
                }
            }
        }

        return false;
    }
}
```


# 链表（14 题）
- [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p1 = headA;
        ListNode p2 = headB;

        while (p1 != p2) {
            if (p1 == null) {
                p1 = headB;
            } else {
                p1 = p1.next;
            }

            if (p2 == null) {
                p2 = headA;
            } else {
                p2 = p2.next;
            }
        }

        return p1;
    }
}
```

```
就是把 null 也当成一个节点，当前是 null 的话，那么下一步就是另一个头结点
要么同时到达 null，要么同时相遇，都是返回 p1
每次循环即使有一个是 null 也要带到 while 循环里面
每次循环要么从 null 到另一个头结点，要么到下一个节点
下方错误代码就是：本身是 null 了，切换到头结点，然后又多走了一个 next（跳过头结点了）
```

```java
if (p1 == null) {
	p1 = headB;
}
if (p2 == null){
	p2 = headA;
}

p1 = p1.next;
p2 = p2.next;
```

- [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode nx = null;

        while (cur != null) {
            nx = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nx;
        }

        return pre;
    }
}
```

- [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode left = head;
        ListNode mid = findMid(head);
        ListNode right = reverse(mid);

        while (right != null) {
            if (left.val != right.val) {
                return false;
            }
            left = left.next;
            right = right.next;
        }

        return true;
    }

    // 靠右的中间节点
    public ListNode findMid(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }

        return slow;
    }

    public ListNode reverse(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode nx = null;
        while (cur != null) {
            nx = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nx;
        }

        return pre;
    }
}
```

- [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;

        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;

            if (slow == fast) {
                return true;
            }
        }

        return false;
    }
}
```

- [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;

            if (fast == slow) {
                ListNode temp = head;
                while (temp != slow) {
                    temp = temp.next;
                    slow = slow.next;
                }

                return temp;
            }
        }

        return null;
    }
}
```

- [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummyHead = new ListNode();
        ListNode cur = dummyHead;

        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                cur.next = list1;
                list1 = list1.next;
            } else {
                cur.next = list2;
                list2 = list2.next;
            }

            cur = cur.next;
        }

        if (list1 != null) {
            cur.next = list1;
        }

        if (list2 != null) {
            cur.next = list2;
        }

        return dummyHead.next;
    }
}
```

- [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode();
        ListNode cur = dummyHead;
        int sum = 0;

        while (l1 != null || l2 != null || sum != 0) {
            if (l1 != null) {
                sum += l1.val;
                l1 = l1.next;
            }

            if (l2 != null) {
                sum += l2.val;
                l2 = l2.next;
            }

            ListNode temp = new ListNode(sum % 10);
            cur.next = temp;
            cur = cur.next;
            sum /= 10;
        }

        return dummyHead.next;
    }
}
```

```
sum 是进位，l1、l2、sum 有一个不为空的时候就能继续算
类比从个位到高位计算，一个高位是 0 一个高位有数字，直接加即可，这里 if(l1 != null) 里面判断为空就是没有这个高位，等价于 sum += 0
```

- [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummyHead = new ListNode(-1, head);
        ListNode fast = dummyHead;
        ListNode slow = dummyHead;

        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }

        slow.next = slow.next.next;
        return dummyHead.next;
    }
}
```

```
先定位到要删除的节点的前面一个节点，再用 slow.next = slow.next.next 删除节点
为什么要 dummyHead？
因为如果只有一个节点的话，当前节点没有前一个节点，所以不能把当前节点删了
```

- [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummyHead =new ListNode(-1, head);
        ListNode cur = dummyHead;
        ListNode first = null;
        ListNode second = null;
        ListNode temp = null;

        while (cur.next != null && cur.next.next != null) {
            first = cur.next;
            second = cur.next.next;
            temp = cur.next.next.next;

            cur.next = second;
            second.next = first;
            first.next = temp;
            cur = first;
        }

        return dummyHead.next;
    }
}
```

```
cur 是交换的两个节点的前面一个节点
注意，交换完后，下一批交换的两个的前一个节点是当前的 first
```

- [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        int n = 0;
        ListNode p1 = head;
        while (p1 != null) {
            p1 = p1.next;
            n++;
        }

        ListNode dummyHead = new ListNode(-1, head);
        ListNode p0 = dummyHead;
        ListNode cur = head;
        ListNode pre = null;
        ListNode nx = null;

        for (int i = 0; i < n / k; i++) {
            for (int j = 0; j < k; j++) {
                nx = cur.next;
                cur.next = pre;
                pre = cur;
                cur = nx;
            }

            ListNode temp = p0.next;
            p0.next = pre;
            temp.next = cur;
            p0 = temp;
        }

        return dummyHead.next;
    }
}
```

```
易错点：
每一轮反转完后，下一轮待交换的前一个节点是这一轮的 temp，不是 pre 了
```

- [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)
```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        Map<Node, Node> map = new HashMap<>();

        Node p = head;
        while (p != null) {
            Node temp = new Node(p.val);
            map.put(p, temp);
            p = p.next;
        }

        Node dummyHead = new Node(-1);
        dummyHead.next = map.get(head);
        p = head;
        while (p != null) {
            Node cur = map.get(p);
            cur.next = map.get(p.next);
            cur.random = map.get(p.random);
            p = p.next;
        }

        return dummyHead.next;
    }
}
```

```
如果遇到超时错误，可能是 while 循环里面没有让 p = p.next
```

- [148. 排序链表](https://leetcode.cn/problems/sort-list/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }

        ListNode left = head;
        ListNode mid = findMid(head);
        ListNode right = mid.next;
        mid.next = null;

        ListNode l1 = sortList(left);
        ListNode l2 = sortList(right);

        return merge(l1, l2);
    }

    public ListNode findMid(ListNode head) {
        // 返回偏左的
        ListNode dummyHead = new ListNode(-1, head);
        ListNode fast = dummyHead;
        ListNode slow = dummyHead;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }

        return slow;
    }

    public ListNode merge(ListNode l1, ListNode l2) {
        // 合并有序链表
        ListNode dummyHead = new ListNode();
        ListNode cur = dummyHead;

        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }

            cur = cur.next;
        }

        if (l1 != null) {
            cur.next = l1;
        }

        if (l2 != null) {
            cur.next = l2;
        }
        return dummyHead.next;
    }
}
```

```
就是归并排序
分成左右两段之后别忘了进入递归

完全均分，偶数的时候返回两端相同的（就是偏左的那个是第一段最后一个）

只有一个节点的时候被分为 left 和 right（null）
```

- [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)：还可以递归，不想写了
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        PriorityQueue<ListNode> queue = new PriorityQueue<>((a, b) -> a.val - b.val);

        int n = lists.length;
        for (int i = 0; i < n; i++) {
            if (lists[i] != null) {
                queue.offer(lists[i]);
            }
        }

        ListNode dummyHead = new ListNode();
        ListNode cur = dummyHead;
        while (!queue.isEmpty()) {
            ListNode temp = queue.poll();
            cur.next = temp;
            if (temp.next != null) {
                queue.offer(temp.next);
            }

            cur = cur.next;
        }

        return dummyHead.next;
    }
}
```

```
构建链表的时候别忘了 cur = cur.next;
```

- [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)
  标准库：
```java
class LRUCache {
    Map<Integer, Integer> cache = new LinkedHashMap<>();
    int capacity = 0;

    public LRUCache(int capacity) {
        this.capacity = capacity;
    }

    public int get(int key) {
        Integer val = cache.remove(key);
        if (val != null) {
            put(key, val);
            return val;
        }

        return -1;
    }

    public void put(int key, int value) {
        Integer val = cache.remove(key);
        if (val != null) {
            cache.put(key, value);
            return;
        }

        if (cache.size() >= capacity) {
            Integer oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }

        cache.put(key, value);
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

```
map 的 remove() 返回值就是删除的 value，否则是 null（本题不存的话返回的 -1）

注意是 LinkedHashMap，这个的 keySet 才能正确使用 cache.keySet().iterator().next();
```

手搓双向链表：
```java
class LRUCache {

    class Node {
        int key;
        int val;
        Node prev;
        Node next;

        Node(int k, int v) {
            key = k;
            val = v;
        }
    }

    Node head = new Node(-1, -1);
    Node tail = new Node(-1, -1);
    Map<Integer, Node> cache = new HashMap<>();
    int capacity = 0;

    public void remove(Node node) {
        Node prev = node.prev;
        Node next = node.next;
        prev.next = next;
        next.prev = prev;
    }

    public void pushFront(Node node) {
        Node prev = tail.prev;
        prev.next = node;
        node.prev = prev;
        node.next = tail;
        tail.prev = node;
    }

    public LRUCache(int capacity) {
        this.capacity = capacity;
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        Node node = cache.get(key);
        if (node != null) {
            remove(node);
            pushFront(node);
            return node.val;
        }

        return -1;
    }

    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node != null) {
            node.val = value;
            remove(node);
            pushFront(node);
            return;
        }

        if (cache.size() >= capacity) {
            Node oldestNode = head.next;
            remove(oldestNode);
            cache.remove(oldestNode.key);
        }
        Node temp = new Node(key, value);
        cache.put(key, temp);
        pushFront(temp);
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

```
太艰难了，双向链表用尾插法，那么最老的节点就是 head.next
cache 只是为了用 key 快速找到 node
淘汰最老的 key 的时候别忘了和 cache 同步删除
```


# 二叉树（15 题）

- [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> ans = new ArrayList<>();

    public List<Integer> inorderTraversal(TreeNode root) {
        dfs(root);
        return ans;
    }

    public void dfs(TreeNode cur) {
        if (cur == null) {
            return;
        }

        dfs(cur.left);
        ans.add(cur.val);
        dfs(cur.right);
    }
}
```

- [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans = 0;

    public int maxDepth(TreeNode root) {
        dfs(root, 0);
        return ans;
    }

    public void dfs(TreeNode cur, int h) {
        if (cur == null) {
            return;
        }

        h++;
        ans = Math.max(ans, h);
        dfs(cur.left, h);
        dfs(cur.right, h);
    }
}
```

- [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        dfs(root);
        return root;
    }

    public void dfs(TreeNode cur) {
        if (cur == null) {
            return;
        }

        TreeNode temp = cur.left;
        cur.left = cur.right;
        cur.right = temp;

        dfs(cur.left);
        dfs(cur.right);
    }
}
```

```
就是每个节点左右交换，然后继续 dfs 遍历
```

- [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return bfs(root);
    }

    public boolean bfs(TreeNode root) {
        if (root == null) {
            return true;
        }

        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root.left);
        queue.offer(root.right);

        while (!queue.isEmpty()) {
            TreeNode L = queue.poll();
            TreeNode R = queue.poll();

            if (L == null && R == null) {
                continue;
            }
            if ((L != null && R == null) || (L == null && R != null)) {
                return false;
            }
            if (L.val != R.val) {
                return false;
            }

            queue.offer(L.left);
            queue.offer(R.right);
            queue.offer(L.right);
            queue.offer(R.left);
        }
        return true;
    }
}
```

```
用 bfs，每次放进去一对节点（左右对称的两个节点）
注意这里是三个 if 判断
都为 null？一个为 null？两个 val 不同？
```

- [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        dfs(root);
        return ans;
    }

    public int dfs(TreeNode cur) {
        if (cur == null) {
            return -1;
        }

        int left = dfs(cur.left) + 1;
        int right = dfs(cur.right) + 1;
        ans = Math.max(ans, left + right);

        return Math.max(left, right);
    }
}
```

```
dfs 遍历每个节点，当前节点最长链是左右子节点最长链 + 1
```

- [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<List<Integer>> ans = new ArrayList<>();

    public List<List<Integer>> levelOrder(TreeNode root) {
        bfs(root);
        return ans;
    }

    public void bfs(TreeNode root) {
        if (root == null) {
            return;
        }

        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int n = queue.size();
            List<Integer> temp = new ArrayList<>();

            for (int i = 0; i < n; i++) {
                TreeNode cur = queue.poll();
                temp.add(cur.val);

                if (cur.left != null) {
                    queue.offer(cur.left);
                }

                if (cur.right != null) {
                    queue.offer(cur.right);
                }
            }

            ans.add(temp);
        }
    }
}
```

- [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        int n = nums.length;
        return dfs(nums, 0, n - 1);
    }

    public TreeNode dfs(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }

        int mid = left + (right - left) / 2;
        TreeNode cur = new TreeNode(nums[mid]);
        cur.left = dfs(nums, left, mid - 1);
        cur.right = dfs(nums, mid + 1, right);

        return cur;
    }
}
```

```
dfs：每次找到当前范围的中间节点 nums[mid]，然后用这个节点作为根节点
```


- [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    long pre = Long.MIN_VALUE;

    public boolean isValidBST(TreeNode root) {
        return dfs(root);
    }

    public boolean dfs(TreeNode cur) {
        if (cur == null) {
            return true;
        }

        boolean left = dfs(cur.left);
        if (!left) {
            return false;
        }

        if (cur.val <= pre) {
            return false;
        }
        pre = cur.val;

        boolean right = dfs(cur.right);
        if (!right) {
            return false;
        }

        return true;

    }
}
```

```
注意 pre 初始化的是 Long.MIN_VALUE
```

- [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int cnt = 0;
    int ans = 0;

    public int kthSmallest(TreeNode root, int k) {
        dfs(root, k);
        return ans;
    }

    public void dfs(TreeNode cur, int k) {
        if (cur == null) {
            return;
        }

        dfs(cur.left, k);

        cnt++;
        if (cnt == k) {
            ans = cur.val;
            return;
        }

        dfs(cur.right, k);
    }
}
```

- [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> ans = new ArrayList<>();

    public List<Integer> rightSideView(TreeNode root) {
        bfs(root);
        return ans;
    }

    public void bfs(TreeNode root) {
        if (root == null) {
            return;
        }

        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            int n = queue.size();
            for (int i = 0; i < n; i++) {
                TreeNode cur = queue.poll();
                if (cur.left != null) {
                    queue.offer(cur.left);
                }
                if (cur.right != null) {
                    queue.offer(cur.right);
                }

                if (i == n - 1) {
                    ans.add(cur.val);
                }
            }
        }
    }
}
```

- [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    TreeNode head; // 默认为 null

    public void flatten(TreeNode root) {
        dfs(root);
    }

    public void dfs(TreeNode cur) {
        if (cur == null) {
            return;
        }

        dfs(cur.right);
        dfs(cur.left);

        cur.left = null;
        cur.right = head;
        head = cur;
    }
}
```

```
按照 右 -> 左 -> 中 顺序遍历
对于每个节点，把 left 设为 null，right 设为 head
```

- [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }

    public TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {
        if (preStart > preEnd || inStart > inEnd) {
            return null;
        }

        int rootVal = preorder[preStart];
        int rootIndex = findIndex(inorder, rootVal);
        int leftSize = rootIndex - inStart;
        TreeNode root = new TreeNode(rootVal);
        root.left = build(preorder, preStart + 1, preStart + leftSize, inorder, inStart, rootIndex - 1);
        root.right = build(preorder, preStart + leftSize + 1, preEnd, inorder, rootIndex + 1, inEnd);
        return root;
    }

    public int findIndex(int[] nums, int x) {
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            if (nums[i] == x) {
                return i;
            }
        }

        return -1;
    }
}
```

```
还是不能一遍过，注意每次的根是 preorder[preStart] 而不是 preorder[0]
初始长度下标是 [0, length - 1] 而不是 [0, length]
```

- [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans = 0;
    Map<Long, Integer> cnt = new HashMap<>();

    public int pathSum(TreeNode root, int targetSum) {
        cnt.put(0L, 1);
        dfs(root, targetSum, 0L);
        return ans;
    }

    public void dfs(TreeNode cur, int targetSum, long sum) {
        if (cur == null) {
            return;
        }

        sum += cur.val;
        ans += cnt.getOrDefault(sum - targetSum, 0);
        cnt.put(sum, cnt.getOrDefault(sum, 0) + 1);
        
        dfs(cur.left, targetSum, sum);
        dfs(cur.right, targetSum, sum);

        // 恢复现场（退出当前节点）
        cnt.put(sum, cnt.get(sum) - 1);
    }
}
```

```
树上前缀和，记得恢复现场（退出当前节点）
```

- [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        return dfs(root, p, q);
    }

    public TreeNode dfs(TreeNode cur, TreeNode p, TreeNode q) {
        if (cur == null || cur == p || cur == q) {
            return cur;
        }

        TreeNode left = dfs(cur.left, p, q);
        TreeNode right = dfs(cur.right, p, q);

        if (left != null && right != null) {
            return cur; // 找到了（左右都非空，这种情况只会出现一次，后面出现的都是只有一个空或者两个都空的情况了）
        }

        if (left == null && right == null) {
            return null;
        }

        if (left != null) {
            return left;
        } else {
            return right;
        }

    }
}
```

```
注意退出条件，没找到返回 null，找到就返回当前节点

找到了（左右都非空，这种情况只会出现一次，后面出现的都是只有一个空或者两个都空的情况了）
```

- [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        dfs(root);
        return ans;
    }

    public int dfs(TreeNode cur) {
        if (cur == null) {
            return 0;
        }

        int left = Math.max(0, dfs(cur.left));
        int right = Math.max(0, dfs(cur.right));
        ans = Math.max(ans, left + right + cur.val);

        return Math.max(left, right) + cur.val;
    }
}
```

```
每次 dfs 返回的是当前节点作为根的时候的最大和
```

# 图论（4 题）
- [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)
- 下一次刷的时候这里的 dfs 改成 dx 和 dy 的形式，统一一下网格图模板
```java
class Solution {
    public int numIslands(char[][] grid) {
        int cnt = 0;
        int m = grid.length;
        int n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    cnt++;
                    dfs(grid, i, j);
                }
            }
        }
        return cnt;
    }

    public void dfs(char[][] grid, int x, int y) {
        int m = grid.length;
        int n = grid[0].length;
        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] != '1') {
            return;
        }

        grid[x][y] = '0';

        dfs(grid, x, y + 1);
        dfs(grid, x + 1, y);
        dfs(grid, x, y - 1);
        dfs(grid, x - 1, y);
    }
}
```

```
遍历每一格的时候记得赋值 grid[x][y] = '0';
```

- [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)
```java
class Solution {
    int count;
    int ans = 0;
    Deque<int[]> queue = new LinkedList<>();
    int[] dx = { 0, 1, 0, -1 };
    int[] dy = { 1, 0, -1, 0 };

    public int orangesRotting(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 2) {
                    queue.offer(new int[] { i, j });
                } else if (grid[i][j] == 1) {
                    count++;
                }
            }
        }

        bfs(grid);
        return count == 0 ? ans : -1;
    }

    public void bfs(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        while (!queue.isEmpty()) {
            int size = queue.size();
            boolean hasNew = false;
            for (int i = 0; i < size; i++) {
                int[] cur = queue.poll();
                int x = cur[0];
                int y = cur[1];

                for (int j = 0; j < 4; j++) {
                    int nx = x + dx[j];
                    int ny = y + dy[j];

                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1) {
                        queue.offer(new int[] { nx, ny });
                        grid[nx][ny] = 2;
                        hasNew = true;
                        count--;
                    }
                }
            }

            if (hasNew) {
                ans++;
            }
        }
    }
}
```

```
类比层序遍历
```

- [207. 课程表](https://leetcode.cn/problems/course-schedule/)
```java
class Solution {
    int cnt = 0;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] d = new int[numCourses];
        int n = prerequisites.length;
        List<List<Integer>> g = new ArrayList<>();

        for (int i = 0; i < numCourses; i++) {
            g.add(new ArrayList<>());
        }
        
        for (int i = 0; i < n; i++) {
            int a = prerequisites[i][0];
            int b = prerequisites[i][1];
            // b -> a
            g.get(b).add(a);
            d[a]++;
        }

        bfs(numCourses, g, d);

        return cnt == numCourses;
    }

    public void bfs(int numCourses, List<List<Integer>> g, int[] d) {
        Deque<Integer> queue = new LinkedList<>();

        for (int i = 0; i < numCourses; i++) {
            if (d[i] == 0) {
                queue.offer(i);
            }
        }

        while (!queue.isEmpty()) {
            int cur = queue.poll();
            cnt++;

            for (int nx : g.get(cur)) {
                d[nx]--;
                if (d[nx] == 0) {
                    queue.offer(nx);
                }
            }
        }
    }
}
```

```
就是拓扑排序
不要用 List<List<Integer>> g = new ArrayList<>(numCourses);
因为只是生成了 numCourses 个 null
应该自己用 for 循环给他 add ArrayList
```


- [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)
- 构造题
```java
class Trie {
    class Node {
        Node[] son = new Node[26];
        boolean end = false;
    }

    Node root;

    public Trie() {
        root = new Node();
    }

    public void insert(String word) {
        Node cur = root;

        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (cur.son[idx] == null) {
                cur.son[idx] = new Node();
            }
            cur = cur.son[idx];
        }

        cur.end = true;
    }

    public boolean search(String word) {
        Node cur = root;

        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (cur.son[idx] == null) {
                return false;
            }
            cur = cur.son[idx];
        }

        return cur.end;
    }

    public boolean startsWith(String prefix) {
        Node cur = root;

        for (char c : prefix.toCharArray()) {
            int idx = c - 'a';
            if (cur.son[idx] == null) {
                return false;
            }
            cur = cur.son[idx];
        }

        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

```
26 叉树，要自己定义节点，每个节点有 26 个子节点
找的时候从 root 开始找
```


# 回溯（8 题）
- [46. 全排列](https://leetcode.cn/problems/permutations/)
```java
class Solution {
    List<Integer> path = new ArrayList<>();
    List<List<Integer>> ans = new ArrayList<>();
    boolean[] used = new boolean[10];

    public List<List<Integer>> permute(int[] nums) {
        dfs(nums);
        return ans;
    }

    public void dfs(int[] nums) {
        int n = nums.length;
        if (path.size() == n) {
            ans.add(new ArrayList<>(path));
        }

        for (int i = 0; i < n; i++) {
            if (used[i]) {
                continue;
            }

            used[i] = true;
            path.add(nums[i]);

            dfs(nums);

            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```

```
看成树形结构遍历就可以了
同时要记录某个元素是否用过
组合的话才需要 startIndex，这样就不用记录某个元素是否用过了，因为从 startIndex 开始往后 dfs
```

- [78. 子集](https://leetcode.cn/problems/subsets/)
```java
class Solution {
    List<Integer> path = new ArrayList<>();
    List<List<Integer>> ans = new ArrayList<>();

    public List<List<Integer>> subsets(int[] nums) {
        dfs(nums, 0);
        return ans;
    }

    public void dfs(int[] nums, int startIndex) {
        ans.add(new ArrayList<>(path));
        int n = nums.length;
        if (path.size() == n) {
            return;
        }

        for (int i = startIndex; i < n; i++) {
            path.add(nums[i]);

            dfs(nums, i + 1);

            path.remove(path.size() - 1);
        }
    }
}
```

- [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
```java
class Solution {
    String[] map = { "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
    StringBuilder path = new StringBuilder();
    List<String> ans = new ArrayList<>();

    public List<String> letterCombinations(String digits) {
        dfs(digits, 0);
        return ans;
    }

    public void dfs(String digits, int idx) {
        int n = digits.length();
        if (idx == n) {
            ans.add(path.toString());
            return;
        }

        String cur = map[digits.charAt(idx) - '0'];
        for (char c : cur.toCharArray()) {
            path.append(c);

            dfs(digits, idx + 1);

            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

```
注意 StringBuilder 几个 api 的使用：
StringBuilder path = new StringBuilder();

path.append('c');

path.deleteCharAt(path.length() - 1);
```

- [39. 组合总和](https://leetcode.cn/problems/combination-sum/)
```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        dfs(candidates, target, 0, 0);
        return ans;
    }

    public void dfs(int[] candidates, int target, int startIndex, int sum) {
        if (sum > target) {
            return;
        }

        if (sum == target) {
            ans.add(new ArrayList<>(path));
            return;
        }

        int n = candidates.length;
        for (int i = startIndex; i < n; i++) {
            path.add(candidates[i]);
            sum += candidates[i];

            dfs(candidates, target, i, sum);

            path.remove(path.size() - 1);
            sum -= candidates[i];
        }
    }
}
```

- [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)
```java
class Solution {
    List<String> ans = new ArrayList<>();

    public List<String> generateParenthesis(int n) {
        char[] path = new char[2 * n];
        dfs(0, 0, n, path);
        return ans;
    }

    public void dfs(int left, int right, int n, char[] path) {
        if (left == n && right == n) {
            ans.add(new String(path));
        }

        if (left < n) {
            path[left + right] = '(';
            dfs(left + 1, right, n, path);
        }

        if (right < left) {
            path[left + right] = ')';
            dfs(left, right + 1, n, path);
        }
    }
}
```

```
注意进入 dfs 的两个 if 条件
一个是 left < n
一个是 rifht < left
这里 path[left + right] = xxx 可以覆盖之前的选择，所以不需要恢复现场
```

- [79. 单词搜索](https://leetcode.cn/problems/word-search/)
```java
class Solution {
    int m = 0;
    int n = 0;
    int[] dx = { 0, 1, 0, -1 };
    int[] dy = { 1, 0, -1, 0 };

    public boolean exist(char[][] board, String word) {
        m = board.length;
        n = board[0].length;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(i, j, board, word, 0)) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean dfs(int x, int y, char[][] board, String word, int idx) {
        if (board[x][y] != word.charAt(idx)) {
            return false;
        }

        if (idx == word.length() - 1) {
            return true;
        }

        board[x][y] = '#';

        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if (nx < 0 || nx >= m || ny < 0 || ny >= n) {
                continue;
            }
            if (dfs(nx, ny, board, word, idx + 1)) {
                return true;
            }
        }

        board[x][y] = word.charAt(idx);

        return false;
    }
}
```

```
经过的点要标记一下，然后恢复现场
遍历每个起点，判断是否可行
每个 dfs 里面如果 idx == word.lengt() - 1，就返回 true
```

- [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)
```java
class Solution {
    List<List<String>> ans = new ArrayList<>();
    List<String> path = new ArrayList<>();

    public List<List<String>> partition(String s) {
        dfs(s, 0);
        return ans;
    }

    public void dfs(String s, int startIndex) {
        if (startIndex == s.length()) {
            ans.add(new ArrayList<>(path));
            return;
        }

        int n = s.length();
        for (int i = startIndex; i < n; i++) {
            if (check(s, startIndex, i)) {
                path.add(s.substring(startIndex, i + 1));

                dfs(s, i + 1);

                path.remove(path.size() - 1);
            }
        }
    }

    public boolean check(String s, int l, int r) {
        while (l < r) {
            if (s.charAt(l) != s.charAt(r)) {
                return false;
            }
            l++;
            r--;
        }

        return true;
    }
}
```

- [51. N 皇后](https://leetcode.cn/problems/n-queens/)
```java
class Solution {
    List<List<String>> ans = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] chessBoard = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                chessBoard[i][j] = '.';
            }
        }
        dfs(chessBoard, n, 0);
        return ans;
    }

    public void dfs(char[][] chessBoard, int n, int row) {
        if (row == n) {
            ans.add(char2List(chessBoard));
            return;
        }

        for (int i = 0; i < n; i++) {
            if (check(chessBoard, row, i, n)) {
                chessBoard[row][i] = 'Q';

                dfs(chessBoard, n, row + 1);

                chessBoard[row][i] = '.';
            }
        }
    }

    public List<String> char2List(char[][] chessBoard) {
        List<String> list = new ArrayList<>();
        for (char[] row : chessBoard) {
            list.add(new String(row));
        }

        return list;
    }

    public boolean check(char[][] chessBoard, int row, int col, int n) {
        // 这一列
        for (int i = row - 1; i >= 0; i--) {
            if (chessBoard[i][col] == 'Q') {
                return false;
            }
        }

        // 45°
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (chessBoard[i][j] == 'Q') {
                return false;
            }
        }

        // 135°
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (chessBoard[i][j] == 'Q') {
                return false;
            }
        }

        return true;
    }
}
```

```
还是很容易错，这个 check 函数得多看几遍，经常有小错误
```

# 二分查找（6 题）
- [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)
```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        // 找到第一个 nums[i] >= target
        int l = 0;
        int r = nums.length - 1;
        int ans = nums.length;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] >= target) {
                ans = mid;
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }

        return ans;
    }
}
```

```
找到第一个 nums[i] >= target
```

- [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)
```java

```

- [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
```java

```

- [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
```java

```

- [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
```java

```

- [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)
```java

```


# 栈（5 题）
- [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)
```java

```

- [155. 最小栈](https://leetcode.cn/problems/min-stack/)
```java

```

- [394. 字符串解码](https://leetcode.cn/problems/decode-string/)
```java

```

- [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)
```java

```

- [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)
```java

```


# 堆（3 题）
- [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
  快速排序以后再看吧，先用桶排序：
```java

```

- [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)
```java

```

- [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)
- 构造题
```java

```


# 贪心算法（4 题）
- [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
```java

```

- [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)
```java

```

- [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)
```java

```

- [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)
```java

```


# 动态规划（10 题）
- [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
```java

```

- [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)
```java

```

- [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)
```java

```

- [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)
  完全背包：一维 -> 从前往后、01 背包：一维 -> 从后往前
  都要先 `dp[0] = 0;`
```markdown
恰好装满问题
是否恰好装满的解法不同只在于初始值的不同
恰好装满:
求最大值时，除了 dp[0]为 0，其他都初始化为无穷小-0 x 3 f 3 f 3 f 3 f
求最小值时，除了 dp[0]为 0，其他都初始化为无穷大 Q 0 x 3 f 3 f 3 f 3 f
不必恰好装满: 全初始化口为 0
```

```java

```

- [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)
```java

```

- [139. 单词拆分](https://leetcode.cn/problems/word-break/)
```java

```

- [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)
```java

```

- [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)
```java

```

- [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
  01 背包：一维 -> 从后往前、完全背包：一维 -> 从前往后
  都要先 `dp[0] = 0;`
```markdown
恰好装满问题
是否恰好装满的解法不同只在于初始值的不同
恰好装满:
求最大值时，除了 dp[0]为 0，其他都初始化为无穷小-0 x 3 f 3 f 3 f 3 f
求最小值时，除了 dp[0]为 0，其他都初始化为无穷大 Q 0 x 3 f 3 f 3 f 3 f
不必恰好装满: 全初始化口为 0
```

```java

```

- [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)
```java

```


# 多维动态规划（5 题）
- [62. 不同路径](https://leetcode.cn/problems/unique-paths/)
```java

```

- [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)
```java

```

- [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
```java

```

- [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)
  子数组是连续子序列：只要遍历完所有节点即可！
```java

```

- [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)
```java

```


# 技巧（5 题）
- [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)
```java

```

- [169. 多数元素](https://leetcode.cn/problems/majority-element/)
```java

```

- [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)
```java

```

- [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)
```java

```

- [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)
```java

```




