记录下每题错误的地方

[LeetCode 热题 100 - 学习计划 - 力扣（LeetCode）全球极客挚爱的技术成长平台](https://leetcode.cn/studyplan/top-100-liked/)

---

# LeetCode hot 100

# 哈希（3 题）
- [1. 两数之和](https://leetcode.cn/problems/two-sum/)
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            if (map.containsKey((target - nums[i]))) {
                return new int[] { map.get(target - nums[i]), i };
            }

            map.put(nums[i], i);
        }

        return new int[] { -1, -1 };
    }
}
```

- [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        int n = strs.length;
        Map<String, List<String>> map = new HashMap<>();
        for (int i = 0; i < n; i++) {
            char[] chars = strs[i].toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);

            List<String> list = map.getOrDefault(key, new ArrayList<>());
            list.add(strs[i]);
            map.put(key, list);
        }

        return new ArrayList<>(map.values());
    }
}
```

```
map 的 key 是 sort 后的字符数组
```

- [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)
```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        int n = nums.length;
        int ans = 0;
        for(int i = 0;i < n;i++){
            set.add(nums[i]);
        }

        for(int x: set){
            int cnt = 1;
            if (set.contains(x - 1)){
                continue;
            }

            int y = x + 1;
            while(set.contains(y)){
                cnt++;
                y++;
            }

            ans = Math.max(ans,cnt);
        }

        return ans;
    }
}
```

```
暴力即可，set 去重，然后遍历 set 通过 while 循环找最长连续
```

# 双指针（4 题）
- [283. 移动零](https://leetcode.cn/problems/move-zeroes/)
```java
class Solution {
    public void moveZeroes(int[] nums) {
        int i = 0;
        int j = 0;
        int n = nums.length;
        for (i = 0, j = 0; j < n; j++) {
            if (nums[j] != 0) {
                swap(nums, i, j);
                i++;
            }
        }
    }

    public void swap(int[] nums, int l, int r) {
        int temp = nums[l];
        nums[l] = nums[r];
        nums[r] = temp;
    }
}
```

```
等价于原地创建新数组，i 是新数组的下标，j 用来遍历原数组
```

- [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
```java
class Solution {
    public int maxArea(int[] height) {
        int l = 0;
        int r = height.length - 1;
        int ans = 0;
        while (l < r) {
            int h = Math.min(height[l], height[r]);
            int d = r - l;
            ans = Math.max(ans, d * h);
            if (height[l] < height[r]) {
                l++;
            } else {
                r--;
            }
        }
        return ans;
    }
}
```

- [15. 三数之和](https://leetcode.cn/problems/3sum/)
```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        int n = nums.length;
        Arrays.sort(nums);

        for (int i = 0; i < n; i++) {
            if (nums[i] > 0) {
                break;
            }

            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }

            int l = i + 1;
            int r = n - 1;
            while (l < r) {
                int sum = nums[i] + nums[l] + nums[r];
                if (sum > 0) {
                    r--;
                } else if (sum < 0) {
                    l++;
                } else {
                    ans.add(List.of(nums[i], nums[l], nums[r]));
                    l++;
                    r--;
                    while (l < r && nums[l] == nums[l - 1]) l++;
                    while (l < r && nums[r] == nums[r + 1]) r--;
                }
            }
        }
        return ans;
    }
}
```

```
去重的方式可以想一想，nums[i] 只取第一个，对于相同的 i，l 和 r 也只取第一个
```

- [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)
```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        int ans = 0;
        int[] lMax = new int[n];
        int[] rMax = new int[n];
        lMax[0] = height[0];
        rMax[n - 1] = height[n - 1];

        for (int i = 1; i < n; i++) {
            lMax[i] = Math.max(lMax[i - 1], height[i]);
        }

        for (int i = n - 2; i >= 0; i--) {
            rMax[i] = Math.max(rMax[i + 1], height[i]);
        }

        for (int i = 0; i < n; i++) {
            ans += Math.min(lMax[i], rMax[i]) - height[i];
        }

        return ans;
    }
}
```

```
典中典
```


# 滑动窗口（2 题）

- [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int ans = 0;
        Set<Character> set = new HashSet<>();
        int n = s.length();
        int l = 0;
        int r = 0;
        for (r = 0; r < n; r++) {
            char c = s.charAt(r);
            while (set.contains(c)) {
                set.remove(s.charAt(l));
                l++;
            }

            set.add(c);
            ans = Math.max(ans, r - l + 1);

        }
        return ans;
    }
}
```

- [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)
```java
class Solution {
    int[] cntP = new int[26];
    int[] cntS = new int[26];
    List<Integer> ans = new ArrayList<>();

    public List<Integer> findAnagrams(String s, String p) {
        for (int i = 0; i < p.length(); i++) {
            cntP[p.charAt(i) - 'a']++;
        }

        int l = 0;
        int r = 0;
        for (r = 0; r < s.length(); r++) {
            char c = s.charAt(r);
            cntS[c - 'a']++;

            if (r - l + 1 > p.length()) {
                cntS[s.charAt(l) - 'a']--;
                l++;
            }

            if (check()) {
                ans.add(l);
            }
        }
        return ans;
    }

    public boolean check() {
        for (int i = 0; i < 26; i++) {
            if (cntS[i] != cntP[i]) {
                return false;
            }
        }
        return true;
    }
}
```

```
cnt[26] 数组存异位字符数组，完全相同则符合题目要求
```


# 子串（3 题）

- [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

![[力扣 hot 100.png|352]]

前缀和中 map 这段的核心逻辑如上图
也可以用前两版的前缀和，练一下前缀和
边算前缀和边算 ans
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int sum = 0;
        int n = nums.length;
        Map<Integer, Integer> cnt = new HashMap<>();
        int ans = 0;
        cnt.put(0, 1);
        for (int i = 0; i < n; i++) {
            sum += nums[i];
            ans += cnt.getOrDefault(sum - k, 0);
            cnt.put(sum, cnt.getOrDefault(sum, 0) + 1);
        }
        return ans;
    }
}
```

单独计算前缀和版：
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int ans = 0;
        int[] sum = new int[n + 1];
        for (int i = 0; i < n; i++) {
            sum[i + 1] = sum[i] + nums[i];
        }

        Map<Integer, Integer> cnt = new HashMap<>();
        cnt.put(0, 1);
        for (int i = 0; i < n; i++) {
            ans += cnt.getOrDefault(sum[i + 1] - k, 0);
            cnt.put(sum[i + 1], cnt.getOrDefault(sum[i + 1], 0) + 1);
        }
        return ans;
    }
}
```

```
只要知道 s[i] 是 s[0,...,i-1] 之和即可
```

- [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            while (!deque.isEmpty() && nums[i] > nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offer(i);

            if (i - deque.peek() + 1 > k) {
                deque.poll();
            }

            if (i - k + 1 >= 0) {
                ans[i - k + 1] = nums[deque.peek()];
            }
        }

        return ans;
    }
}
```

```
这里用到的是双端队列，注意这里没有 popLast() 方法，只有 pollLast() 把他看成队列即可
push 的时候保持内部递减，因为左边小于右边的肯定不可能是答案
内部左边是最大值，也就是答案（前提是左边在范围内）
```

- [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)
  参考：[76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/solutions/258513/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/?envType=study-plan-v2&envId=top-100-liked)
```java
class Solution {
    public String minWindow(String s, String t) {
        int ansLeft = -1;
        int ansRight = s.length();
        int[] need = new int[128];
        int count = t.length();

        for (int i = 0; i < count; i++) {
            need[t.charAt(i)]++;
        }

        int r = 0;
        int l = 0;
        for (r = 0; r < s.length(); r++) {
            char c = s.charAt(r);
            if (need[c] > 0) {
                count--;
            }
            need[c]--;

            while (count == 0) {
                if (r - l < ansRight - ansLeft) {
                    ansLeft = l;
                    ansRight = r;
                }

                c = s.charAt(l);
                l++;
                need[c]++;
                if (need[c] > 0) {
                    count++;
                }
            }
        }
        return ansLeft == -1 ? "" : s.substring(ansLeft, ansRight + 1);
    }
}
```

```
r 不断往右，直到符合要求，这个时候 l 不断往右，直到不符合要求
不需要的字符最多就会让 need 加到 0，如果加到 > 0 的话，就说明需要这个字符（count++）
```

# 普通数组（5 题）

- [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        int ans = nums[0];
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```

```
dp[i] 是 nums[i] 结尾的最大大小
dp[n - 1] 只是最后结尾的大小，所以应该用 ans 记录全局大小
```

- [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)
```java
class Solution {
    public int[][] merge(int[][] intervals) {
        int n = intervals.length;
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        List<int[]> ans = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            int[] cur = intervals[i];

            if (i == 0) {
                ans.add(cur);
                continue;
            }

            int[] pre = ans.get(ans.size() - 1);
            if (pre[1] >= cur[0]) {
                pre[1] = Math.max(pre[1], cur[1]);
            } else {
                ans.add(cur);
            }
        }

        return ans.toArray(new int[ans.size()][]);
    }
}
```

```
return ans.toArray(new int[ans.size()][]);
括号里面写的是数组的大小
```

- [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)
```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k = k % n;

        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }

    public void reverse(int[] nums, int l, int r) {
        while (l < r) {
            int temp = nums[l];
            nums[l] = nums[r];
            nums[r] = temp;
            l++;
            r--;
        }
    }
}
```

- [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)
  参考：[238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/solutions/2783788/qian-hou-zhui-fen-jie-fu-ti-dan-pythonja-86r1/?envType=study-plan-v2&envId=top-100-liked)
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] l = new int[n];
        int[] r = new int[n];
        int[] ans = new int[n];

        l[0] = 1;
        for (int i = 1; i < n; i++) {
            l[i] = l[i - 1] * nums[i - 1];
        }

        r[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            r[i] = r[i + 1] * nums[i + 1];
        }

        for (int i = 0; i < n; i++) {
            ans[i] = l[i] * r[i];
        }

        return ans;
    }
}
```

```
注意 l[i] 表示 [0,i-1] 的乘积，r[i] 表示 [i+1,n-1] 的乘积
所以 l[0] = [0,-1] 的乘积就是 1 
这样当 i = 1 的时候就等价于 1 * r[1]
```

- [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)
```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            while (nums[i] >= 1 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                int j = nums[i] - 1;
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }

        for (int i = 0; i < n; i++) {
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }

        return n + 1;
    }
}
```

```
换座位，只找正数，所以只找 1 <= nums[i] <= n 的数据
nums[i] 应该在 nums[i] - 1 的下标处
对于每个位置，必须换到换不了为止，所以要用 while
如果用 if 的话意思是把 nums[i] 换到正确位置，然后 i++，但是 i 位置不一定是正确的数字，所以必须用 while 一直换，换到符合要求（换到换不了为止）
```


# 矩阵（4 题）
- [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)
```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        boolean row = false;
        boolean col = false;
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                col = true;
                break;
            }
        }

        for (int i = 0; i < n; i++) {
            if (matrix[0][i] == 0) {
                row = true;
                break;
            }
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        for (int i = 1; i < m; i++) {
            if (matrix[i][0] == 0) {
                for (int j = 0; j < n; j++) {
                    matrix[i][j] = 0;
                }
            }
        }

        for (int i = 1; i < n; i++) {
            if (matrix[0][i] == 0) {
                for (int j = 0; j < m; j++) {
                    matrix[j][i] = 0;
                }
            }
        }

        if (row) {
            for (int i = 0; i < n; i++) {
                matrix[0][i] = 0;
            }
        }
        if (col) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```

```
注意操作都是从 int i = 1 开始的
第零行第零列最后才判断
```

- [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        List<Integer> ans = new ArrayList<>();
        int[] dx = { 0, 1, 0, -1 };
        int[] dy = { 1, 0, -1, 0 };
        int x = 0;
        int y = 0;
        int idx = 0;

        for (int i = 0; i < m * n; i++) {
            ans.add(matrix[x][y]);
            matrix[x][y] = Integer.MAX_VALUE;
            
            int nx = x + dx[idx];
            int ny = y + dy[idx];
            
            if (nx < 0 || nx >= m || ny < 0 || ny >= n || matrix[nx][ny] == Integer.MAX_VALUE) {
                idx = (idx + 1) % 4;
                nx = x + dx[idx];
                ny = y + dy[idx];
            }

            x = nx;
            y = ny;
        }

        return ans;
    }
}
```

错误地方：你是在“走到非法位置之后”才转向，**但没有回退**
```java
// 错误代码
if (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] == Integer.MAX_VALUE) {
    idx = (idx + 1) % 4;
    x = x + dx[idx];
    y = y + dy[idx];
}
ans.add(matrix[x][y]);
```
只有在下一个位置没问题的时候，才让 x 和 y 变成下一个位置

- [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)
```java
class Solution {
    public void rotate(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < i; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        for (int i = 0; i < m; i++) {
            int l = 0;
            int r = n - 1;
            while (l < r) {
                int temp = matrix[i][l];
                matrix[i][l] = matrix[i][r];
                matrix[i][r] = temp;
                l++;
                r--;
            }
        }
    }
}
```

- [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length;
        int n = matrix[0].length;

        for (int i = 0; i < m; i++) {
            int l = 0;
            int r = n - 1;
            while (l <= r) {
                int mid = l + (r - l) / 2;
                if (matrix[i][mid] > target) {
                    r = mid - 1;
                } else if (matrix[i][mid] < target) {
                    l = mid + 1;
                } else {
                    return true;
                }
            }
        }

        return false;
    }
}
```


# 链表（14 题）
- [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p1 = headA;
        ListNode p2 = headB;

        while (p1 != p2) {
            if (p1 == null) {
                p1 = headB;
            } else {
                p1 = p1.next;
            }

            if (p2 == null) {
                p2 = headA;
            } else {
                p2 = p2.next;
            }
        }

        return p1;
    }
}
```

```
就是把 null 也当成一个节点，当前是 null 的话，那么下一步就是另一个头结点
要么同时到达 null，要么同时相遇，都是返回 p1
每次循环即使有一个是 null 也要带到 while 循环里面
每次循环要么从 null 到另一个头结点，要么到下一个节点
下方错误代码就是：本身是 null 了，切换到头结点，然后又多走了一个 next（跳过头结点了）
```

```java
if (p1 == null) {
	p1 = headB;
}
if (p2 == null){
	p2 = headA;
}

p1 = p1.next;
p2 = p2.next;
```

- [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode nx = null;

        while (cur != null) {
            nx = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nx;
        }

        return pre;
    }
}
```

- [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode left = head;
        ListNode mid = findMid(head);
        ListNode right = reverse(mid);

        while (right != null) {
            if (left.val != right.val) {
                return false;
            }
            left = left.next;
            right = right.next;
        }

        return true;
    }

    // 靠右的中间节点
    public ListNode findMid(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }

        return slow;
    }

    public ListNode reverse(ListNode head) {
        ListNode pre = null;
        ListNode cur = head;
        ListNode nx = null;
        while (cur != null) {
            nx = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nx;
        }

        return pre;
    }
}
```

- [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;

        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;

            if (slow == fast) {
                return true;
            }
        }

        return false;
    }
}
```

- [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;

            if (fast == slow) {
                ListNode temp = head;
                while (temp != slow) {
                    temp = temp.next;
                    slow = slow.next;
                }

                return temp;
            }
        }

        return null;
    }
}
```

- [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummyHead = new ListNode();
        ListNode cur = dummyHead;

        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                cur.next = list1;
                list1 = list1.next;
            } else {
                cur.next = list2;
                list2 = list2.next;
            }

            cur = cur.next;
        }

        if (list1 != null) {
            cur.next = list1;
        }

        if (list2 != null) {
            cur.next = list2;
        }

        return dummyHead.next;
    }
}
```

- [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyHead = new ListNode();
        ListNode cur = dummyHead;
        int sum = 0;

        while (l1 != null || l2 != null || sum != 0) {
            if (l1 != null) {
                sum += l1.val;
                l1 = l1.next;
            }

            if (l2 != null) {
                sum += l2.val;
                l2 = l2.next;
            }

            ListNode temp = new ListNode(sum % 10);
            cur.next = temp;
            cur = cur.next;
            sum /= 10;
        }

        return dummyHead.next;
    }
}
```

```
sum 是进位，l1、l2、sum 有一个不为空的时候就能继续算
类比从个位到高位计算，一个高位是 0 一个高位有数字，直接加即可，这里 if(l1 != null) 里面判断为空就是没有这个高位，等价于 sum += 0
```

***2025.12.27***
- [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummyHead = new ListNode(-1, head);
        ListNode fast = dummyHead;
        ListNode slow = dummyHead;

        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }

        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }

        slow.next = slow.next.next;
        return dummyHead.next;
    }
}
```

```
先定位到要删除的节点的前面一个节点，再用 slow.next = slow.next.next 删除节点
为什么要 dummyHead？
因为如果只有一个节点的话，当前节点没有前一个节点，所以不能把当前节点删了
```

- [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummyHead =new ListNode(-1, head);
        ListNode cur = dummyHead;
        ListNode first = null;
        ListNode second = null;
        ListNode temp = null;

        while (cur.next != null && cur.next.next != null) {
            first = cur.next;
            second = cur.next.next;
            temp = cur.next.next.next;

            cur.next = second;
            second.next = first;
            first.next = temp;
            cur = first;
        }

        return dummyHead.next;
    }
}
```

```
cur 是交换的两个节点的前面一个节点
注意，交换完后，下一批交换的两个的前一个节点是当前的 first
```

- [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        int n = 0;
        ListNode p1 = head;
        while (p1 != null) {
            p1 = p1.next;
            n++;
        }

        ListNode dummyHead = new ListNode(-1, head);
        ListNode p0 = dummyHead;
        ListNode cur = head;
        ListNode pre = null;
        ListNode nx = null;

        for (int i = 0; i < n / k; i++) {
            for (int j = 0; j < k; j++) {
                nx = cur.next;
                cur.next = pre;
                pre = cur;
                cur = nx;
            }

            ListNode temp = p0.next;
            p0.next = pre;
            temp.next = cur;
            p0 = temp;
        }

        return dummyHead.next;
    }
}
```

```
易错点：
每一轮反转完后，下一轮待交换的前一个节点是这一轮的 temp，不是 pre 了
```

- [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)
```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/

class Solution {
    public Node copyRandomList(Node head) {
        Map<Node, Node> map = new HashMap<>();

        Node p = head;
        while (p != null) {
            Node temp = new Node(p.val);
            map.put(p, temp);
            p = p.next;
        }

        Node dummyHead = new Node(-1);
        dummyHead.next = map.get(head);
        p = head;
        while (p != null) {
            Node cur = map.get(p);
            cur.next = map.get(p.next);
            cur.random = map.get(p.random);
            p = p.next;
        }

        return dummyHead.next;
    }
}
```

```
如果遇到超时错误，可能是 while 循环里面没有让 p = p.next
```

- [148. 排序链表](https://leetcode.cn/problems/sort-list/)
```java

```

- [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)：还可以递归，不想写了
```java

```

- [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)
- 学一下手搓链表
```java

```


# 二叉树（15 题）
- [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)
```java

```

- [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)
```java

```

- [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)
```java

```

- [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)
```java

```

- [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)
```java

```

- [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)
```java

```

- [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)
```java

```

- [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)
```java

```

- [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)
```java

```

- [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)
```java

```

- [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)
```java

```

- [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
```java

```

- [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)
```java

```

- [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)
```java

```

- [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)
```java

```


# 图论（4 题）
- [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)
```java

```

- [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)
```java

```

- [207. 课程表](https://leetcode.cn/problems/course-schedule/)
```java

```

- [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)
- 构造题
```java

```


# 回溯（8 题）
- [46. 全排列](https://leetcode.cn/problems/permutations/)
```java

```

- [78. 子集](https://leetcode.cn/problems/subsets/)
```java

```

- [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)
```java

```

- [39. 组合总和](https://leetcode.cn/problems/combination-sum/)
```java

```

- [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)
```java

```

- [79. 单词搜索](https://leetcode.cn/problems/word-search/)
```java

```

- [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)
```java

```

- [51. N 皇后](https://leetcode.cn/problems/n-queens/)
```java

```


# 二分查找（6 题）
- [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)
```java

```

- [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)
```java

```

- [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)
```java

```

- [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
```java

```

- [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
```java

```

- [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)
```java

```


# 栈（5 题）
- [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)
```java

```

- [155. 最小栈](https://leetcode.cn/problems/min-stack/)
```java

```

- [394. 字符串解码](https://leetcode.cn/problems/decode-string/)
```java

```

- [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)
```java

```

- [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)
```java

```


# 堆（3 题）
- [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
  快速排序以后再看吧，先用桶排序：
```java

```

- [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)
```java

```

- [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)
- 构造题
```java

```


# 贪心算法（4 题）
- [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)
```java

```

- [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)
```java

```

- [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)
```java

```

- [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)
```java

```


# 动态规划（10 题）
- [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)
```java

```

- [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)
```java

```

- [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)
```java

```

- [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)
  完全背包：一维 -> 从前往后、01 背包：一维 -> 从后往前
  都要先 `dp[0] = 0;`
```markdown
恰好装满问题
是否恰好装满的解法不同只在于初始值的不同
恰好装满:
求最大值时，除了 dp[0]为 0，其他都初始化为无穷小-0 x 3 f 3 f 3 f 3 f
求最小值时，除了 dp[0]为 0，其他都初始化为无穷大 Q 0 x 3 f 3 f 3 f 3 f
不必恰好装满: 全初始化口为 0
```

```java

```

- [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)
```java

```

- [139. 单词拆分](https://leetcode.cn/problems/word-break/)
```java

```

- [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)
```java

```

- [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)
```java

```

- [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
  01 背包：一维 -> 从后往前、完全背包：一维 -> 从前往后
  都要先 `dp[0] = 0;`
```markdown
恰好装满问题
是否恰好装满的解法不同只在于初始值的不同
恰好装满:
求最大值时，除了 dp[0]为 0，其他都初始化为无穷小-0 x 3 f 3 f 3 f 3 f
求最小值时，除了 dp[0]为 0，其他都初始化为无穷大 Q 0 x 3 f 3 f 3 f 3 f
不必恰好装满: 全初始化口为 0
```

```java

```

- [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)
```java

```


# 多维动态规划（5 题）
- [62. 不同路径](https://leetcode.cn/problems/unique-paths/)
```java

```

- [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)
```java

```

- [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)
```java

```

- [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)
  子数组是连续子序列：只要遍历完所有节点即可！
```java

```

- [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)
```java

```


# 技巧（5 题）
- [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)
```java

```

- [169. 多数元素](https://leetcode.cn/problems/majority-element/)
```java

```

- [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)
```java

```

- [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)
```java

```

- [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)
```java

```




